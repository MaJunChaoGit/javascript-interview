### 从输入URL到页面加载——浏览器接收URL开启网络请求线程



#### 浏览器是多进程的

- 浏览器是多进程的
- 浏览器之所以能够运行,是因为系统给它的进程分配了资源(cpu、内存)
- 每打开一个页面，就相当于创建了一个独立的进程
- 根据浏览器的优化策略，有时多个页面的进程会被合并



#### 浏览器包含哪些进程

1. Browser进程：浏览器的主进程（负责调度），只有一个。
   - 负责浏览器的界面显示，与用户交互。如前进，后退等
   - 负责各个页面的管理，创建和销毁其他进程
   - 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
   - 网络资源的下载，管理等
2. 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件的时候才创建
3. GPU进程：最多一个，用于WebGL ，3D绘制等
4. 浏览器渲染进程（Renderer进程）：默认每个页面一个进程，互不影响。主要负责
   - 页面渲染，js脚本执行，事件处理，定时器等



#### 浏览器多进程的优势

相比于单进程浏览器，多进程有如下优点：

- 避免单个页面崩溃导致整个浏览器崩溃
- 避免第三方插件崩溃导致整个浏览器崩溃
- 充分利用多核优势，提升性能
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性



#### 重点是Renderer进程

先看Renderer进程包含哪些常驻线程:

1. GUI渲染线程
   - 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等
   - 当界面需要重绘时，或者由于某种操作引发回流时，该线程就会执行
   - GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等待JS引擎空闲时立即被执行
2. JS引擎线程
   - 也称为JS内核，负责处理JS脚本程序
   - JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Renderer进程中无论什么时候只有一个JS线程在运行
   - GUI渲染线程与JS引擎线程是互斥的，所以如果JS引擎的执行时间过程，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞
3. 事件触发线程
   - 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
   - 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
   - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
   - 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
4. 定时触发器线程
   - 传说中的`setInterval`与`setTimeout`所在线程
   - 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
   - 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
   - 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
5. 异步http请求线程
   - 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
   - 将检测到状态变更时，如果设置有回调函数，异步线程就**产生状态变更事件**，将这个回调再放入事件队列中。再由JavaScript引擎执行。



#### 总结

​	以Chrome为例、当打开浏览器时，浏览器会创建**负责统一调度管理的Browser主进程**、**负责图形绘制GPU进程**、**用于扩展浏览器的第三方插件进程**以及**最重要的浏览器内核进程**。浏览器通过开辟多个进程进行管理可以防止其中一个页面或者一个插件的崩溃导致的整个浏览器崩溃，并且通过多进程提升浏览器的性能。

​	当用户输入URL后，浏览器将会针对此页面开启浏览器Renderer内核进程，此进程中包含了**负责页面解析，样式渲染的GUI线程** 、**负责解析运行JS的JS引擎线程**、**负责事件循环调度的事件触发线程**、**负责定时器触发的定时器触发线程**以及**负责网络请求的异步HTTP请求线程**。

​	**未完待续**



