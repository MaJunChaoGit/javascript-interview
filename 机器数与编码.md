### 机器数与编码



#### 计算机"眼中"的数字

计算机内数据和指令都是由晶体管和门电路等元件完成的，对于这些元件来说，`开`或者`关`是其唯一的状态，这种状态的表现就是二进制的理念。就像黑客帝国世界中漫天飞的`0`和`1`一样,计算机世界使用的**机器语言**也只有`0`和`1`。而在**机器语言**中，当计算机想要表示一个数字时，这时就得使用**机器数**了，**机器数**所表示的真实数值称为**真值**。



机器数有两个特点：

1. 符号数字化，通常机器数以最高位表示正负号，即`0`代表正数，`1`代表负数。
2. 数值的大小受字长显示，如8bit的机器，其可表示的**真值**数值范围为`-127` ~ `+127`，**机器数**即`11111111` ~ `01111111`。




---




#### 数字的“单位”

- **位(bit)**

  位，音译为“比特”，没错，就是比特币的比特，它表示计算机内部二进制数码存储的最小单位。

  如：0001是一个4位的二进制数。

- **字节（Byte）**

  字节，音译为“拜特”，字节是信息量的基本单位，一个字节可容纳8**位**二进制数码，即1个字节等于8个比特（1byte=8bit）。通常情况下，1个字节可以存入一个*ASCII码*，2个字节可以存放一个汉字国标码。


- **字（Word）**

  字是计算机中每次 作为一个整体进行处理的二进制数码。一个字通常由一个或多个字节组成。

- **字长（Word Length）**

  计算机中每个字所包含的位数称为字长,字长标志着计算机每次运算的最大精度，它是计算机性能的重要指标。通常CPU与内存之间的数据传送单位是一个字长，内存中用于指明一个存储位置的地址也经常是以字长为单位的。

>根据排列组合原理，一个字长为n位的字，最多能够表示出2<sup>n</sup>种不同的二进制数码。其中，数值2<sup>n</sup> 就称为该字的**模(Modulo)**。



---



#### **小数点的“位置”**

在**机器数**中，小数点的位置是隐含指定的。小数点的处理方式有以下两种方式：

- **定点（Fixed Point）数**

  在运算过程中，小数点的位置是始终固定不变的。

  例如：

  纯整数形式：`XXXXXX.`

  纯小数形式：`.XXXXXX`

  整数和小数形式：`XXXX.XX`

- **浮点(Floating Point)数**

  在运算过程中，小数点的位置可以根据实际需要来改变，但不能改变数值的大小。

  例如：

  123.4 = 12.34 *10<sup>1</sup> = 1.234 * 10<sup>2</sup> =  0.1234 * 10<sup>3</sup>

  可见，虽然浮点数中小数点的位置不同，但是数值的大小是不变的。

  浮点数主要包括尾数（Mantissa）、指数（Exponent）、底数（Base）三个部分。

![MEN](C:\Users\Administrator\Desktop\MEN.png)

其中，尾数是数值的有效部分，尾数中的小数点只是形式上的，它在数值中的实际位置是由指数来确定的。底数值是固定不变得，一般在计算机中省略不写。



---



#### 带符号的整数

在计算机中，数的“+”、“-”符号是无法直接识别的，只能用二进制数字0和1去标记。整数的正负号通常放在一个`字`的最高位(Most Significant Bit),存放符号标记的位称为**符号位**。有符号的机器数有以下表现形式：

1. **原码（Primitive Encoding）**

   在机器数中,如果整数的绝对值用二进制数表示，“+”、“-”符号分别用0和1去表示，这种表示方式就称为原码，记为 [x]<sub>原</sub>。其中x为真值，[x]表示真值为x的机器数，下标“原”表示该机器数为原码的表示形式。

   设字长为8，+3和-3用原码表示如下：

   +3 = [+0000011]<sub>原</sub> = 00000011

   -3 = [-0000011]<sub>原</sub> = 10000011

   一般来说,字长为n的原码可以定义为：

   ![pe](C:\Users\Administrator\Desktop\pe.png)

   其中，真值x（整数）的表示范围是-(2<sup>n-1</sup>-1) <= x <= 2<sup>n-1</sup>-1。圆括号右侧的下标2表示其中的内容为二进制数。

   原码表示简单易懂，它与真值之间的转换也非常方便。

   >但计算机用原码进行加减运算的过程和脑力计算类似。
   >
   >例如，两个数相减，先要根据它们的绝对值大小来决定是否要交换位置，绝对值大的数作为被减数放在前面，小的作为减数，求出结果后还要加上正确的符号。

   ​

2. **补码（Complement）**

   为了简化加、减运算过程，提出了补码的概念。在介绍补码之前，先来做一个二进制计数的实验。

   ![com](C:\Users\Administrator\Desktop\com.png)

   设有一个4位二进制加/减计数器，从计数器的初值0000开始，分别进行加1和减1计数。由表中可见，对于计数值为0~7的正数来说，计数器的最高有效位为0。而对于小于0但不小于-8的计数值来说，计数器的最高有效位为1，因此，在一定的计数范围内的计数器最高有效位的状态可以用来表示数的正负。

   注意计数器在0000状态下减1的情况，由于不够减，实际上计数器已向高位发出了借位信号，这时计数器的减1结果与二进制运算10000-1的结果是等价的。因此，当计数值x小于0时，计数器的内容（机器数）实际已变成如下形式：

   ![cc](C:\Users\Administrator\Desktop\cc.png)

   其中，10000B=2<sup>4</sup>就是4位计数器的“模”。实际上，上图表格的内容可以通过以下补码定义方式来表示：

   ![comDe](C:\Users\Administrator\Desktop\comDe.png)

   其中，n为字长，真值x(整数)的表示范围是：-2<sup>n-1</sup> <= x <= 2<sup>n-1</sup>-1，常数（10<sup>n</sup>）<sub>2</sub> = 2<sup>n</sup>是字的模。

   ​

   设字长为8，根据上面补码定义，3和-3的补码表示如下：

   +3 = [+0000011]<sub>补</sub> = 00000011

   -3 = [-0000011]<sub>补</sub> = 100000000 - 0000011 = 11111101

   由补码的定义可知，两个互为相反数的补码满足以下关系。

   [x]<sub>补</sub> + [-x]<sub>补</sub> = 10<sup>n</sup>B （-2<sup>n-1</sup> <= x <= 2<sup>n-1</sup>，n为字长）

   这表明[x]<sub>补</sub>与[-x]<sub>补</sub>相对模10<sup>n</sup>B（即2<sup>2</sup>）是互补的,补码一词就是由此而来。

   由此可见，用补码表示的机器数不但可以省去减法运算，而且在加法运算过程中不必考虑两个数的大小和正负，大大简化了加减运算过程。

   ​

3. **反码（Invert Encoding）**

   虽然补码可以省去减法运算，但根据补码定义求补码仍需要做减法运算。为了避免求补码过程中的减法运算，提出了**反码**的概念。

   反码的定义与补码的定义类似：

   ![invert](C:\Users\Administrator\Desktop\invert.png)

   其中，n为字长，真值x（整数）的表示范围是-（2<sup>n-1</sup> - 1） <= x <= 2<sup>n-1</sup> - 1。

   设字长为8，根据上面反码定义，3和-3的反码表示如下：

   +3 = [+0000011]<sub>反</sub> = 00000011

   -3 = [-0000011]<sub>反</sub> = 100000000 -1 - 0000011 = 11111111 - 00000011 = 11111100

   反码定义式中

   ![ins](C:\Users\Administrator\Desktop\ins.png)

   的情况。这样一个n位全为“1”的数与负数x相加的结果就是负数x逐位取反。

   这也是反码一词的由来。

   >对照补码和反码的定义可知，负数的反码是有补码减1所得。
   >
   >在计算机中对二进制数的取反操作是十分容易的，所以，若要得到一个数的补码可以先取其反码，然后再对反码加1即可。

   ​

   >根据上面补码与反码的之间的关系，还可以得到一种直接通过二进制数取负数补码的方法，即从二进制数的最低有效位（LSB）开始起向左，直到遇见第一个“1”为止所有数字都不变（包括这个“1”），第一个“1”以后各位数字全部取反，直到满足相应字长要求为止。

   ![speedCom](C:\Users\Administrator\Desktop\speedCom.png)


---



#### 整数的大小比较与移码

在计算机中，通常利用减法运算结果来判断两个数的大小。

![btable](C:\Users\Administrator\Desktop\btable.png).

在机器数中，通过借位状态来判断两个无符号数的大小是比较方便的。但通过结果的符号位来判断两个有符号数（补码）的大小则较为麻烦。**首先，不能通过借位状态判断它们的大小，因为如果是两个异号数相减，由于执行的相加运算，借位状态已无意义。其次，相减结果的正负有可能因溢出而无法正确表示。**为了便于有符号数的大小比较，在计算机中常用“移码”来表示有符号数。所谓移码是指将有符号数x加上正偏移值B后所形成的无符号数,即

<center>[x]<sub>移</sub> = B + x<center>

其中，偏移值B为一个整数，它等于真值x最小数的绝对值。真值x的取值不能超出有符号机器数的表示范围。

字长为n的移码与补码之间的关系式：

<center>[x]<sub>移</sub> = B + [x]<sub>补</sub> （mod 2<sup>n</sup>）</center>

其中，x为整数，其范围是-2<sup>n-1</sup> <= x < 2<sup>n-1</sup>。B为一个正整数，在这里 B = |x<sub>min</sub>| = 2<sup>n-1</sup>。下面列出了8位补码、移码与真值之间的对应关系。

| 真值x  |    补码    |    移码    |
| :--: | :------: | :------: |
| 127  | 01111111 | 11111111 |
| 126  | 01111110 | 11111110 |
| ...  |   ...    |   ...    |
|  1   | 00000001 | 10000001 |
|  0   | 00000000 | 10000000 |
|  -1  | 11111111 | 01111111 |
| ...  |   ...    |   ...    |
| -127 | 10000001 | 00000001 |
| -128 | 10000000 | 00000000 |

可见，移码已将有符号数转为无符号数，因此可以像判断无符号数那样来判断移码的大小。由于移码的大小关系对应真值的大小关系是一样的，它与补码的转换又非常方便，所以可以通过移码间接的判断补码（有符号数）的大小。



----



####总结

文章摘自



