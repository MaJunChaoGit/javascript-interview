### Webpack面试题

1. **为什么要用webpack?**

   随着时代的推进,作为一个前端程序员,我们以往使用的前端三件套已经不能满足于我们的要求了.比如说,我们使用Vue,React等应用框架提高了我们的开发效率,但是这些框架又要求用一些规定的文件格式去编写组件,模块等,如.vue,.jsx文件等.这些文件浏览器是无法认识的,需要进行特定的解析才能给浏览器使用,也就是说在使用这些框架的同时还额外多出一些编译的模块需要被安装及使用.

   再比如说传统的css样式复用性及维护是很麻烦的,与之而来的less,scss等面向对象的样式也同样需要进行编译的过程才能被浏览器使用,甚至于程序员们已经不能满足于js,在项目中加入的flow,typescript等强类型的语法.这些上述所有都模块最终都要服务于浏览器,手动去维护这些模块不现实,而webpack强大的功能恰恰好能帮我们解析上述流程.

2. **webpack与grunt,gulp有什么不同?**

   三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。

   [grunt](http://link.zhihu.com/?target=https%3A//www.gruntjs.net/)和[gulp](http://link.zhihu.com/?target=https%3A//www.gulpjs.com.cn/)是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。

   webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。

   所以总结一下：

   - 从构建思路来说

   ```
   gulp和grunt需要开发者将整个前端构建过程拆分成多个`Task`，并合理控制所有`Task`的调用关系
   webpack需要开发者找到入口，并需要清楚对于不同的资源应该使用什么Loader做何种解析和加工
   ```

   - 对于知识背景来说
     gulp更像后端开发者的思路，需要对于整个流程了如指掌 webpack更倾向于前端开发者的思路

3. **使用了哪些Plugin,用来解决什么问题?**

   - HotModuleReplacementPlugin

     热加载模块主要是用来解决团队开发效率以及开发体验,通过热加载模块,webpack会自动帮我们更新改变的内容,样式等.

   - CopyWebpackPlugin

     拷贝模块主要是解决我们在开发SDK包中,有一些静态文件需要发布到最终打包文件路径下.

   - GenerateAssetPlugin

     我主要通过该模块与localStorage结合,生成形成一套前端的配置文件.

   - DefinePlugin

     主要通过该模块进行编译期间的全局变量定义,通过这些变量会对这个webpack打包的流程和代码编译进行干涉,可以做到一些选择性的打包.

   - OtherPlugin

     当然还有一些常用的如压缩混淆代码,Vue组件插件,Webpack进度条,HTML模板生成,CSS样式提出,SASS和LESS的单独提出等插件也经常使用.

4. **使用了哪些Loader,用来解决什么问题?**

   - worker-loader

     该loader主要用于让工程可以更好的支持webWoker特性

   - url-loader

     根据文件的大小,对字体和图片进行base64的转码,减少网络上的请求

   - babel-loader

     可以支持jsx,es6等语法,并通过webpack与babel整合生成浏览器兼容的es5语法

   - vue-loader

     用于解析vue文件

5. **Loader和Plugin 的不同?**

   loader主要是用于加载转化一些webpack资深无法加载的文件,如jsx,vue等.他的作用的加载,并作用于一个个文件上.

   plugin的作用是用于拓展一些webpack的功能,它将直接作用与webpack之上,相比于loader只专注于解析加载文件,plugin的功能更加的丰富.

6. **webpack热更新的实现?**

   已有文章

7. **webpack优化**

   - 项目主要是基于Cesium框架做的一些修改与扩展,Cesium库打包后也非常庞大,我们使用externals进行优化,让webpack避免重复打包该库,并且让其可以通过es6的import进行引入
   - 使用happypack对loader的执行过程从单一进程的形式拓展为多进程模式,从而在不修改配置的情况下提提高了编译过程的速度
   - 使用uglify对代码进行压缩,减少代码下载的时间
   - 通过commonsChunkPlugin对js代码进行分割,并通过require.ensure进行按需加载

8. **webpack的构建流程?**

   Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：

   1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；
   2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；
   3. 确定入口：根据配置中的 entry 找出所有的入口文件；
   4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
   5. 完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
   6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
   7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

   在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。

