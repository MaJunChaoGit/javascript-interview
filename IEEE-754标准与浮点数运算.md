#### 序言

本文主要简述了计算机中数字的表示方式，以及IEEE-754标准的由来及具体规定，最后简单的叙述了浮点数的运算规则。阅读这篇文章之前，最好有关于有关于[机器数中的原码、反码、补码三种形式](https://blog.csdn.net/m0_37972557/article/details/84575849)的一些概念。





#### 计算机"眼中"的数字

计算机内数据和指令都是由晶体管和门电路等元件完成的，对于这些元件来说，`开`或者`关`是其唯一的状态，这种状态的表现就是二进制的理念。就像黑客帝国世界中漫天飞的`0`和`1`一样,计算机世界使用的**机器语言**也只有`0`和`1`。而在**机器语言**中，当计算机想要表示一个数字时，这时就得使用**机器数**了，**机器数**所表示的真实数值称为**真值**。

> 机器数（computer number）是将符号"数字化"的数，是数字在计算机中的二进制表示形式。机器数有2个特点：一是符号数字化，二是其数的大小受机器字长的限制

机器数有两个特点：

1. 符号数字化，通常机器数以最高位表示正负号，即`0`代表正数，`1`代表负数。
2. 数值的大小受字长显示，如8bit的机器，其可表示的**真值**数值范围为`-127`~`+127`，**机器数**即`11111111`~`01111111`。

那么我们以8bit二进制为例,看看**机器数原码**如何表示10进制中的`3`和`-3`。

```
对于正数符号位为0,所以机器数为00000011
对于负数符号位为1,所以机器数为10000011
```



---



#### IEEE标准的由来

在上文中，我们知道计算机通过**二进制**可以精确的表达整数，那么计算机是如何表达小数，或者说计算机是如何处理这些小数的呢？

在早期，计算机表示小数的方式是**定点小数**的方式去表示的，**定点小数**中。小数点隐含在第一位编码和第二位中间。

```
如真值为正值的小数0.101,使用定点小数在计算机中表示就为0 101
```

> 然而，早期使用定点小数无法表示过大和过小的值，并且在计算过程由于数值范围的限定，会出现数值溢出的问题。

随着技术的更新，在1978年的时候，Intel公司推出了首枚**16bit微处理器(CPU)[8086](https://en.wikipedia.org/wiki/Intel_8086)**。这台**x86**的老祖宗虽然自身无法处理小数的运算，但是在编译器层面可以通过用整数指令模拟出小数的运算，不过这种运算的方式效率是非常低的。

为了解决这类问题，1980年Intel公司推出了首款**x87浮点协处理器运算单元(FPU)[8087](https://en.wikipedia.org/wiki/Intel_8087)**，通过主板上额外的**协处理器插槽**，安装后不仅可以解决小数的运算问题，并且对于不同的应用，性能提升了20%~500%。

对于计算机发展来说，**8087**是款非常棒的**FPU**，但是它的意义真正体现在这款**FPU**的设计师之一的**William Kahan**教授设计了**IEEE-754标准**的雏形，而正是因为这套标准，我们计算机才能精准的处理小数。

1985年时，IEEE推出了[IEEE 754-1985](https://en.wikipedia.org/wiki/IEEE_754-1985)标准，随着大佬们的努力，IEEE还推出了目前的版本——[IEEE 754-2008](https://en.wikipedia.org/wiki/IEEE_754-2008_revision)。

而我们使用的高级语言中浮点数的运算，如C、C++、JavaScript、Java都是基于这个标准而定。



---



#### IEEE 754规范

1. **组成**

   IEEE 754标准中，浮点格式主要分为四种类型，即单精度格式、双精度格式、扩展单精度格式和扩展双精度格式。它们的构成都由以下三部分组成：

   - 符号位，控制数值的正负
   - 指数位，控制数值的大小
   - 尾数位，控制数值的精度

   我们以64位的双精度Double类型为例，他的构成是如下图所示。

   ![img](https://img-blog.csdn.net/20180821174847621?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NTIxNjU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   - 第1位：符号位，`0`表示正数，`1`表示负数
   - 第2位到第12位（共11位）：指数部分，指数部分一共有11个二进制位，最大是11个`1`，即范围为`0`到`2047`。
   - 第13位到第64位（共52位）：尾数部分（即有效数字）

   ​

   所有四种浮点格式各个部分组成如下图，引用自[QAWRA](https://blog.csdn.net/wallc/article/details/72674712)![浮点格式参数](https://img-blog.csdn.net/20170524111255109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FsbGM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

2. **正规化**

   对于十进制计算来说，小数`0.0011`既可以表示成`1.1 x 10<sup>-3</sup>`，也可以表示成`11 x 10<sup>-4</sup>`。

   但是对于**机器数**而言，统一的标准规定它首要需要**正规化**，也就是必须唯一地表示小数点的位置：

   ![img](https://upload-images.jianshu.io/upload_images/6168671-e7f76c9418c334b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/163/format/webp)

   上图中`b`是由`0`或`1`构成的二进制数，`b`通常由`十进制`转`二进制`而来，它会自动忽略起始位置的**隐藏位**`1.`，`b`最终被存入上图中`尾数部分`。`p`加上`移码`后的二进制数存入上图`指数部分`。

   >对于一个非0的二进制数来说，我们可以保证尾数部分一直以`1`开始，那么我们通过把第一位的`1`当做隐藏位，默认它的存在，并不把它存入尾数部分，这样就可以提高1位数据表示的精度。

3. **移码**

   上述介绍中有个词：**移码** 。

   我们知道`指数`是有正值或负值的，既然有负值那么就得用`最高位`来表示正负符号。也就是说如果是`11位`的**机器数**，实际上影响数值大小的位数只有10位，并且我们可以得出十进制范围为 `-1023`~`1024`。

   如果我们以`-1023`~`1024`作为该数的指数范围区间，**那么为了比较数据是否在范合理围内，将不可避免的进行负值加法的运算**，为了解决这个问题，大佬们提出`移码` 的概念。其中有两个特殊值：`-1023`和`1024`后面会解释。


   >用移码来表示阶码有以下几种好处。
   >
   >1.方便比较大小和加减
   >
   >2.保证浮点数的机器零为0
   >
   >3.特殊值（0和max）比较容易检验
   >
   >4.提高表示数据的精度

4. **非正规化**

   正规化告诉我们浮点数的最左边**隐藏位**无论何时都是1，那么对于`0`就无法表示了。大佬们通过规定如果指数部分为0时，尾数部分就再也不是`1.bbbbbb`的形式了，而是`0.bbbbbb`这种非**正规化**的表示形式，这样如果尾数部分全部为`0`时，即表示该数值为`0`。下图是64位双精度非正规化的表示方式：

   ![fzg](F:\javascript-interview\fzg.png)

5. **无穷大和NaN**

   当指数为**最小值**时表示非正规化，而当指数为`最大值+1`，尾数部分全部为0就表示`无穷大`，当尾数不全为0就为`NaN`。

6. **机器数中的ε**

   **ε**表示1与大于1的最小浮点数之差，不同精度的浮点的**ε**是不同的。一般来说**ε**是根据不通精度的尾数部分宽度来定的。例如双精度有52位的尾数宽度p，那么该精度下**ε**为2<sup>-52</sup>，如下：![e](F:\javascript-interview\e.png)

7. **无小数浮点数二进制表示**

   首先我们通过上述结论我们可以得到以下求值公式。

   ```
   (-1) ^ 符号位 * 1.bbbbb... * 2 ^ 指数部分
   ```

   下面我们使用`4399`这个十进制整数我们套用上述公式，反推得到以下64位2进制浮点数结果。

   1. 首先我们将`4399`转为2进制数`1000100101111`，因为是正数，那么符号位为 `0`。 然后我们根据正规化的二进制浮点数表达，那么它以`1.bbbbb...`这种形式表示为`1.000100101111 x 2<sup>12</sup>`
   2. 去除隐藏位`1`之后尾数部分为：`000100101111`。
   3. 指数`12`经过偏移加上`1023`换算为二进制：`10000001011`。
   4. 最终在计算机中存储的结果为：` 0-10000001011-00010010111100...000`

   最后，推荐大家一个[IEEE 754 64位转换工具](http://www.binaryconvert.com/convert_double.html)方便大家测试自己的运算结果。


---



#### 浮点数的运算规则

在了解了浮点数表示的标准，与机器数编码标准后，我们来看看计算机中的浮点数是如何运算的。

浮点数运算分为两个部分，阶码运算与尾数运算，并且所有运算均采用补码运算，具体的运算一般可以分为以下五个个步骤，我将试着通过一个浮点数加减法的实际案例结合以下五个步骤进行同步说明：

假设有两组IEEE-754标准的64位双精度浮点数：



第一组**x**浮点数为: `0  01111111011  1001100110011001100110011001100110011001100110011010`

第二组**y**浮点数为: `0  01111111100  1001100110011001100110011001100110011001100110011010`

现在需要进行求x+y的值。

1. 对阶

   对于浮点数来说，两浮点数进行加减，首先看两数的阶码是否相同，即小数点位置是否对齐。若两数阶码相同，表示小数点是对齐的，就可以进行尾数相加减，反之，此时需要使两数的阶码相同，这个过程叫做对阶。 

   对于对阶来说需要注意的是：

   - 对阶的原则是`小阶对大阶`，`小阶对大阶`的好处是，当小阶不同于大阶时，只需要移除小阶数的尾数部分的低位部分，如果是大阶对小阶的话，就需要移除大阶的高位部分了，这样的误差是无法接受的。
   - 为了减少精度的损失，我们将尾数移除的数字进行保留，供以后的舍入（第四部分）处理。

   ```
   x的阶码为 01111111011
   y的阶码为 01111111100
   计算 01111111011 - 01111111100
   转为补码计算的加法 01111111011 + (-01111111100) = 01111111011 + 10000000100[补]
   得出的结果转为原码 11111111111[补] = -1[十]
   由于得知x与y的阶差为-1,所以我们需要将小阶x的尾数右移一位
   原x的尾数部分1001100110011001100110011001100110011001100110011010
   右移后x的尾数11001100110011001100110011001100110011001100110011010
   根据0舍1入原则,右移移位后,尾数补上隐藏位的1,舍去移除的0,最后得到x的尾数部分为:
   1100110011001100110011001100110011001100110011001101
   ```

   > 注意对阶完成后，不管是加减运算，此时原数的阶码已经为大阶的阶码了

2. 尾数计算

   由于已经对阶完成，我们只需要将52位尾数部分+1位隐藏进行加减计算。

   > 如果隐藏位被右移了，那么默认补0

   ```
     0.1100110011001100110011001100110011001100110011001101
   + 1.1001100110011001100110011001100110011001100110011010
   ————————————————————————————————————————————————————————
    10.0110011001100110011001100110011001100110011001100111
   ```

   ` 10.0110011001100110011001100110011001100110011001100111` 就是尾数计算后的结果。

3. 结果规格化

   根据规格化的要求，我们需要将第2部计算出的尾数右移1位，并将阶码+1

   ```
   0  01111111101  0011001100110011001100110011001100110011001100110011(1)
   这里计算后1隐藏位还是继续隐藏。
   ```

   > 右移后的尾数为上面的数字，这里需要注意的是，最低位被右规了1，造成精度丢失的问题

4. 舍入

   根据0舍1入的规则，由于我们右规了1，所以要进行+1的预算。

   ``` 
     0011001100110011001100110011001100110011001100110011
   + 0000000000000000000000000000000000000000000000000001
   ————————————————————————————————————————————————————————
     0011001100110011001100110011001100110011001100110100
   ```

5. 溢出判断

   阶码`01111111101`是没有发生上下溢出的情况的。所以舍入后的结果为最终的尾数部分。


最终我们得到IEEE-754的浮点数`0  01111111101  0011001100110011001100110011001100110011001100110100`

将它转换为10进制数得到`0.30000000000000004440892098500626`

而题目中的x和y是`0.1`和`0.2`。

说到这里聪明的你应该知道为什么0.1+0.2不等于0.3了吧。