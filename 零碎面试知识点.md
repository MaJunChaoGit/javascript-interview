

### 零碎面试知识点

1. **let暂时性死区**

   暂时性死区指一旦进入当前作用域时,所要使用的变量就已经存在了,但是此时无法使用.只有通过定义声明之后才可以使用和获取.

2. **给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值**

   a = a ^ b;   [1000 0001 1001]

   b = a ^ b;   [1001 0001 1000]

   a = a ^ b;   [1001 1000  0001]

3. **数组去重问题**

   var arr = Array.from(new Set([...arr]));

4. **cookie和webStorage的区别，如果cookie被篡改怎么办**

   - cookie的大小受到浏览器的限制,一般只有4K左右

     cookie是对http协议的拓展, cookie的内容保留在请求头中,也就是说每次请求cookie都将伴随在浏览器与服务器间,这样会造成不必要的浪费

     对于服务器端语言来说处理cookie较简单,但是对于前端来说原生的方法还是通过正则表达式进行分割处理

   - sessionStorage的大小为5M.可以存储较多的数据

     sessionStorage与服务器的session相似,是会话级别的数据,一旦关闭浏览器数据将消失

     sessionStorage有非常方便的API

     不同窗口时无法共享数据的

   - localStorage大小也为5M

     他是一种持久化的方案,如果不手动清除不会消失

     不同窗口非跨域的情况可以共享数据

   可以根据业务的需要生成签名,如果签名被篡改则无法通过验证

5. **经常碰见的http状态码**

   - 200	一切正常
   - 101 websocket通信已建立
   - 304 自从上次请求后,请求的网页未修改过.一般配合缓存标头一块使用
   - 400 请求的语法错误
   - 401 前端没有通过鉴权
   - 404 请求路径未找到
   - 405 请求的方法没有匹配
   - 500 服务器遇到了错误

6. **跨域的解决方案**

   - JSONP

     通过script标签进行跨域的请求,通过回调函数接收到服务端的数据,并通过script标签进行运行.

     他的好处是兼容性比较高,但是只能支持GET请求,并且不能够支持iframe之间的通信

   - CORS

     通过服务器设置CORS与请求头中Origin相匹配即可请求

   - PROXY

     通过发送请求给服务端,让服务端代为请求

7. **因为引用计数产生的内存泄漏，在ES6中的解决办法是什么**

   通过WeakMap和WeakSet进行解决,因为是弱类型数据结构,垃圾回收会自动进行回收.

8. **==和===的区别**

   - === 是表示等同符,只有当两边完全相等的时候才会返回true

   - == 是等值符,当两边类型相同时会比较值是否相同,当两边类型不同时,会进行类型的转换

     如果是boolean,string,number类型会优先转换为数字进行比较

     如果是null或undefined是彼此相等的

9. **箭头函数中的this**

   箭头函数在执行中是不存在this上下文的,他将直接捕获父级作用域中this

10. **['1', '2', '3'].map(parseInt)**

  1. parseInt(‘1’, 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1；
  2. parseInt(‘2’, 1) // 基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN；
  3. parseInt(‘3’, 2) // 基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN。

11. **实现一遍双向绑定**

    已有案例

12. **服务端渲染是什么?**

    从一开始的服务端渲染转变到SPA/CSR,到现在比较热门的SSR,其实是经历了下面这段过程的:

    在JSP年代,后端程序员往往不可避免的要涉及到前端的一部分知识,例如JSP上的数据绑定,以及路由页面的跳转.在那个时候前端程序员的工作仅仅是画个页面,写个JS的交互而已,所以程序员的鄙视链在那个时候是比较严重的.后来随着nodejs,前端mvc框架的兴起让前端所能做的事情越来越多,前端的业务也越来越重,前端发现自己翻身的机会来了.并且由于全力支持这两种技术,很多不应该做成SPA的页面,也做成了SPA.而SPA虽然在用户操作的体验上得到了提升,但是最主要的首屏加载速度慢和SEO的问题是无法解决的.而通过nodejs进行SSR被前端看做唯一的出路,自己选择的路得自己走完,人家后端也不想趟你这摊浑水.于是从以前的后端负责SSR,转变为前端通过nodejs作为中间件进行SSR,看似是历史的倒退,其实则是前端的发展与机会,随着Vue,React都支持SSR,前端的生态会变得越来越好的.

13. **虚拟DOM**

    通常浏览器的GUI引擎解析HTML时,首先会将请求的字节流转换为字符流,并且对字符流通过分词以及词法分析生成一根DOM树.再通过CSS分析器执行上述解析过程得到一根CSSDOM树.通过DOM节点中的attach方法将样式与之关联,生成render对象,这些对象最终会被构建成一根Render树,再有了Render数据后,浏览器将会开始布局,他会计算每个元素节点中所对应浏览器的精确坐标,最后调用节点的paint方法进行渲染.

    也就是当我们调用操作DOM的方法时,浏览器就会重新执行上述步骤.显然,当我们一下调用10次,将会导致10次重绘,其中计算样式等操作就变成了无用功.

    而虚拟DOM就是为了解决这个浏览器的问题而被设计出来的,他将缓存更新,去除不必要的计算,最终一次性的attach到DOM树中,通知浏览器进行绘制.

    虚拟DOM其实就是一个javaScript对象,对象其中的属性映射了DOM节点的各种属性.最终通过render函数生成一个节点对象添加到DOM树中即可更新视图.

    那么其中涉及到比较的部分是由diff算法的改进版本来实现的,传统的diff算法首先会对新树与旧树进行两两比较,然后对其变化的部分执行增删改,整个过程是O(n^3)的时间复杂度.而react和vue对其diff算法进行优化,使得放弃了深度遍历而只进行同级比较,并且如果节点类型不同直接采取替换的策略,通过对元素添加key可以使得时间复杂度提升到O(n).

    最终生成的新节点挂载到DOM树上即可.

14. **HTTP1.0/HTTP1.1/HTTP2.0/HTTPS区别**

    HTTP协议是建立与TCP协议之上的,所以HTTP的优化及瓶颈也是基于TCP协议本身,比如说TCP的3次握手与4次挥手以及每次的慢启动.

    影响一个HTTP请求主要因素有两个: 带宽和延迟

    对于带宽来说,现在的基础网络设施还是比较完善的,不用太担心带宽所带来的影响.

    而对于延迟来说,影响主要体现在三个方面:

    - 浏览器的阻塞, 浏览器对于同一个域名,每次同时只能有6个链接左右,也就是说超过6个请求就会产生阻塞,这也是为什么一些要求较高的站点需要有多个CDN服务
    - DNS查询,DNS查询是非常消耗时间的,一般用DNS缓存和预解析来进行优化
    - 建立链接, 浏览器与服务器通信最快也要进行3次握手才能进行HTTP报文传输,如果这些链接无法复用的话会造成每次请求都进行握手与慢启动

    针对上述问题,HTTP1.1进行了一些优化:

    - HTTP/1.1引入了长连接与管道化的概念,即TCP连接默认不关闭,可以被多个请求进行复用
    - 相对于HTTP/1.0,HTTP/1.1还引入了更多的缓存策略,从之前的Last-Modified/If-Modified-Since服务器缓存控制转变为Etag/if-None-Math的客户端缓存控制.

    而对于HTTP1.1来说,他的主要缺点在于,虽然TCP请求得以复用,但是服务器还是只能等上一个请求处理完才会进行下一个请求的处理,后面将会有很多请求排队,形成'队头阻塞'.

    针对上述的问题,HTTP2.0有进行了一些优化:

    - 采用了二进制分帧的,将之前的报文头部的文本格式转变为二进制流的格式
    - 采用了首部压缩的机制,由于HTTP是无状态的,所以需要通过在请求头中传递很多信息表示当前的状态.每次在请求的时候都会发送一模一样的内容,这就导致了带宽上的浪费,HTTP/2.0针对此问题做了一些优化,通过压缩算法将请求头进行压缩,并且客户端与服务器端通过索引其中参数共同维护一个请求头信息表,提高了传输的效率
    - 多路复用的技术使得客户端浏览器可以在同一个TCP连接中发送多个请求和响应,并且不需要按照顺序来进行解析,避免了'队头阻塞'的情况
    - 由于数据包在传输的过程中是不按照顺序来进行传输的,所以需要对每个数据包进行标记.客户端发送的数据流默认为奇数,服务器发出的为偶数,数据流发送到一半时,服务器和客户端都可以针对这个请求进行取消,而不影响TCP连接,而以前我们只能通过关闭TCP连接来达到取消请求的目的.
    - HTTP/2.0还支持服务器的主动推送,常见的场景用于第一次客户请求网页时,还附带很多静态资源.正常情况下需要在进行二次请求这些静态资源,而有了服务器推送时,服务器完全可以在第一次请求时直接将静态资源与网页一次发送给客户端

    而HTTPS其实是HTTP的安全版本,HTTP的通信采用的明文传输,明文传输会带来窃听,篡改数据的风险.HTTPS通过SSL/TLS进行HTTP通信以达到信息加密的传输,防止身份被冒充,数据被篡改.

    SSL/TLS整个握手流程如下:

    - 客户端请求建立SSL连接,并向服务器发送一个随机数和客户端所支持的加密算法
    - 服务器从其中选出一组算法,并回复一个随机数,并将安全证书和公钥一起发送给浏览器
    - 浏览器接收到之后,会验证该证书是否合法,如果通过验证将会生成第三个随机数,并通过双方约定好的算法与接收到公钥一起加密这个随机数.
    - 服务器通过自己的私钥解密这个随机数,并通过3个随机数一起生成最终的对话密钥,并在之后通过这个密钥加密所有通信的内容.

15. **TCP3次握手和4次挥手**

    TCP3次握手是指建立TCP通信需要经过3次数据包发送来可以进行数据的传输.3次握手大致流程如下:

    1. 此时服务器与客户端都是CLOSED状态.首先客户端主动向服务器发送TCP请求,其中请求的报文首部SYN = 1,表示这是一个请求的报文.并且还会生成一个随机数seq = x作为初始序列号一起发送给服务器,此时客户端进入SYN_SENT.
    2. 当服务器通过验证上述请求后,其中报文首部SYN = 1,ACK = 1,表示这是一个响应报文.并且也会生成一个随机数seq = y和一个确认数,这个确认数为客户端传来的初始序号加1,即ack = x + 1,此时服务器为SYN_RECV.
    3. 当客户端接受到服务器的同步包之后,其中报文首部ACK =1,表示这是一个确认的报文.并且会向服务器发送一个序列号seq = x + 1,确认号为 y + 1,此包发送完毕后开启TCP连接,进入ESTAB_LISHED状态,完成三次握手.

    如果只通过2次握手可能会导致,客户端发送的请求报文由于网络原因延迟了,等到服务器与客户端通信结束了这个延迟的报文才传输到服务器,此时又开启了一个没有意义的TCP链接,所以需要3次握手,并且双方都确定的这个环节才开启通信以保证通信的完整性.

    TCP4次挥手是指关闭TCP通信需要经过4次数据包的发送,4次挥手大致流程如下:

    1. 此时服务器与客户端都处于ESTABLISHED状态.首先客户端发出连接关闭请求,并且停止发送数据.其中报文首部为FIN = 1,表示这是一个释放连接的报文.并且根据最后一个数据包字节的序号+1生成序列号seq = u,此时客户端为FIN_WAIT1终止等待1状态.
    2. 服务器接收到客户端连接释放报文后,发出确认报文.其中报文首部为ACK =1,表示这是一个确认的报文.此时客户端已经不发送数据给服务器了,服务器处于半关闭的关闭等待状态.但是服务器如果还有数据没有发送完还将继续发送.
    3. 服务器最后的数据包发送完毕之后,会发送连接释放报文,其中首部为FIN = 1,确认号为ack = u + 1,并且根据最后的数据包字节发送自己的序列号seq = w,此时服务器计入最后确认last-ACK状态
    4. 当客户端接收到服务器的报文后,会发出最后的确认报文,其中首部为ACK = 1,确认号为ack = w + 1,此时客户端会进入一个2MSL的等待时间.
    5. 最终服务器接收到客户端的报文后关闭连接.

    为什么会有2MSL,由于最后客户端确认的报文有可能产生丢失,导致服务器重新发送一次连接释放报文,如果有这个2MSL的时间.客户端可以重新进行确认关闭.

16. **请求头和响应头**

    请求头:

    - Accept 表示可接受的响应类型
    - Accept-Charset 表示可接受的字符集
    - Accept-Language 表示可接受的语言列表
    - Connection 表示连接的类型
    - Cookie
    - Host 表示服务器的域名及端口号
    - Origin 发起跨域请求的来源
    - User-Agent 浏览器操作系统的标识

    响应头:

    - Access-Control-Allow-Origin 表示允许跨域的网站地址
    - Server 服务器名称
    - Status 响应码
    - Content-Encoding 响应的字符编码类型
    - Content-Langurage 响应语言类型

17. **Promise**

    Promise是ES6提出的一种异步解决方案,在没有Promise之前,我们需要使用回调函数来处理异步问题,如果异步获得数据又有关联的话,需要将回调函数进行嵌套,形成回调函数地狱.在ES6时代往往用Promise来解决异步的问题更加舒服一些.

    在Promise的内部,实际上存在三种状态,pending,fulfilled,rejected.Promise的状态一旦改变就不会再次发生变化了,通过构造器中传入的resolve和rejected可以将Promise的状态改变,并且可以通过刚才两个函数进行传入异步的数据,通过promise.then方法就可以进行调用了.promise还有一些如all,race的API,一个是对一组异步处理,最后一个处理完之后的调用.一个是当前一组最快一个完成异步调用.

18. **手写ajax**

    已有

19. **快速排序**

    已有案例

20. **浏览器缓存的过程**

    当浏览器发送请求时,首先会根据请求头中的配置Cache-Control与Expires的过期的时间判断是否需要走缓存走,如果没有过期直接返回200(from cache).如果过期的话,会优先根据Etag来进行缓存策略,此时发送给服务器的请求头中包含if-None-match,如果没有配置Etag的话会根据last-modified,并向服务器发送if-modified-since.服务器根据请求头的信息决策是否需要走缓存走,如果需要的话返回304,如果文件有更新的话会返回200,由浏览器与服务器进行协商缓存.

21. **ES新特性有哪些**

    常用的有ES7的数组的includes函数和求幂函数,es8的async和await,

22. **ajax、axios与fetch有什么区别？**

    - 传统的ajax指的是XMLHttpRequest对象的一系列操作,一般ajax还指的是jQuery对其的封装.在此基础上它还支持jsonp请求,经过多年的使用及改进,使用起来已经非常方便的,但是还是有如下缺点:
      - jQuery整个项目太大,为了使用ajax而对其引入不太符合性能上的要求
      - 基于事件的处理异步方案不友好,回调函数如果存在迭代关系的,会造成ca llback地狱
      - 不符合关注点分离原则,本身是针对MVC的编程,与目前大热的MVVM不太切合
    - Vue中主推的是大家用axios替换ajax方案,axios是一个基于Promise的ajax实现版本 .优点上来说支持Promise的API是大家喜好的主要原因,并且提供了并发请求的接口,且对于拦截请求和响应都有了一系列的支持.
    - fetch号称是ajax的替代品,它不是对XMR封装,它是最原生的js
      - 符合关注点的分离,没有将输入,输出,状态混杂到一个对象中
      - 更好更方便的写法,基于Promise实现,还支持async和await
      - 它默认是不带cookie发送的,并且对于400,500报错的请求,并不会reject,并且不支持abort取消请求,造成了流量的浪费

23. **行内元素,块级元素,空元素有哪些?**

    - 行内元素

      a b span input button label

    - 块级元素

      div ul li dt dl h1~h6 p

    - 空元素

      br link hr img input

24. **CSS选择器有哪些?他们的优先级?**

    - 基本选择器

      \#id、.class、 div、 selector1,selector1、 *

    - 层次选择器

      E F、 E > F、 E + F、 E ~ F

    - 伪类选择器

      E:[hover | link | active | visited | E:focus]

      E:[checked | enabled | disabled]

      E:[first-child | last-child | nth-child]

      E:not(F)

    - 属性选择器

      [attr]

      [attr=value]

      [attr~=value]

      [attr!=value]

      [attr^=value]

      [attr$=value]

      [attr*=value]

    1. **第一等：代表内联样式，如: style=””，权值为1000。**
    2. **第二等：代表ID选择器，如：#content，权值为0100。**
    3. **第三等：代表类，伪类和属性选择器，如.content，权值为0010。**
    4. **第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。**
    5. **通配符、子选择器、相邻选择器等的。如\*、>、+,权值为0000。**
    6. **继承的样式没有权值。**

25. **link和@import的区别**

    1. link是HTML的写法,@import是CSS的写法
    2. link是支持并行下载的,而@import是串行下载的,会发生页面的阻塞
    3. link是可以通过js控制的,@import是不可以的

26. **CSS的盒子模型**

    - 标准盒子模型:

      总宽度 = 内容宽度(content) + padding + border + margin

    - IE盒子模型:

      总宽度 = 内容宽度(content + boder + padding) + margin

27. **CSS垂直居中的几种方式**

    - 通过table-cell进行设置

      对想要居中的元素设置display: table-cell;

      并且设置vertical-align: middle;text-align: center;

    - 通过flex弹性盒子设置

      对象居中的元素的父元素设置display: flex;

      并且设置justify-content: center; item-align: center;

    - 通过负margin实现

      子元素绝对定位,并且知道宽高.top:50%;left:50%;margin-left: -width / 2; margin-top: -height / 2;

    - 通过translate设置

      父元素设置相对定位

      子元素绝对定位,top:50%;left:50%;transfrom: translate(-50%, -50%);

28. **隐藏元素的几种方式及区别**

    - diplay: none

      隐藏后,原来的位置被删除了,导致了浏览器的回流


    - visibility: hidden

      隐藏后,保留了原来的位置,只会导致重绘,不会回流

    - opacity: 0;

      隐藏后,还可以触发事件

29. **span元素的宽高多少**

    ```html
    <div style=”width:400px;height:200px;”>
      <span style=”float:left;width:auto;height:100%;”>
        <i style=”position:absolute;float:left;width:100px;height:50px;”>hello</i>
      </span>
    </div>
    ```

    width: 0px; height: 200px;

    由于span元素默认为行内元素所以没有宽和高,而float之后会变成块级元素.

    height为父元素的高度200px,宽度设置的为auto则由子元素进行决定.

    子元素的由于是absolute定位,脱离了文档流,不占据宽度,所以span的宽度为0px;

30. **清除浮动的几种方法**

    - 通过伪元素::after

      clear:both;content:"";overflow:hidden;height:0;

    - 通过添加空div

      clear:both;

    - 通过bfc

      父级元素overflow:hidden

    - 通过display:table

      display:table;宽度的话会默认以子元素撑开宽度

31. **微任务和宏任务**

    - 宏任务按顺序执行,且浏览器再每个宏任务之间渲染页面
    - 所有微任务也按顺序执行,且在以下场景会立即执行所有微任务
      - 每个回调之后且JS执行栈为空
      - 每个宏任务结束

32. **BFC原理与float机制**

33. **逻辑运算优先级**

    逻辑或与逻辑与都为短路运算,一般逻辑与返回第一个为false,或第二个为true的值

    逻辑或返回第一个为true,或最后一个为false的值

    0 || 1 = 1
    1 || 2 = 1
    0 && 1 = 0
    1 && 2 = 2

34. **下列代码的输出多少**

    因为键名会为[object Object]字符串的形式

    var a={},
    ​    b={key:'b'},
    ​    c={key:'c'};

    a[b]=123;
    a[c]=456;

    console.log(a[b]); // 456

35. **对1000000000进行分割为1.000.000.000**

    var str = "1000000000";

    str = str.replace(/(?=(\B)(\d{3})+$)/g, ".");

36. **正则判断,正确的格式如：\$1,023,032.03 或者 \$2.03，错误的格式如：\$3,432,12.12 或者 \$34,344.3**

    /^\$\d{1,3}(,\d{3})*(\.\d{2})?$/.test(str);

37. **JSONP为什么只支持GET请求?**

    JSONP原理是动态添加一个script标签,利用src去请求脚本不受限制的特性来完成跨域请求,这样的模式目前来说只能是GET方法.

38. **git rebase的作用**

    - 合并多个commit为一个完整的commit

      git rebase -i \[startpoint\] \[endpoint\]弹出交互式窗口完成合并操作

      startpoint和endpoint指明了编辑的区间,如果不指定endpoint的话,默认是当前分支的HEAD所指向

39. **BFC介绍一下**

    BFC译名叫做块级格式上下文,它是由多个块级元素组成的一个独立容器空间,并且BFC内部有着自己的布局规则且不受到外部的影响.

    - **什么情况下会产生BFC**

      文档根元素

      position: absolute,fixed;

      float不为none
      overflow不为visiable

      display为flex,table-cell,inline-block

    - **BFC内部的布局规则**

      BFC内部是按照从上而下的堆叠方式进行排列的

      他的高度间隙是由margin-top/bottom来决定的,同一个BFC下的相邻的块级元素的margin-top与margin-bottom会产生堆叠

      BFC内部的浮动元素也参与高度的计算

    - **BFC可以做什么**

      通过BFC解除float父级元素的高度塌陷问题

      防止margin重叠的问题

      自适应两栏布局

40. **关于float的深入理解**

    借用张鑫旭大神的观点,float本是一个用来解决文字环绕的方案,结果因为对于布局来说非常好用,所以被滥用成了布局方案.从本质上来说float与inline-block差不多,两者都具备元素的包裹性,但是相比inline-block来说float还具备一个方向性,但是从页面设计角度来说 从右到左的情况反而不是太多,两者的差距其实没有那么明显,完全可以用inline-block替代float.并且float本身还具备一些破坏性,比如以文字环绕图片为例来说,float其实破坏的是图片本身的inline-box的高度,导致了line-box整体的高度变低了,而文字本身具备一些高度,所以产生了环绕的效果.但是对于没有文字的空的div,反而会产生高度塌陷的情况,这个只是我们用错了方法,而不是一个bug.

41. **对于display: inline-block的理解**

    这题主要有问题的地方有两点

    1. 第一点是使用了inline-block会让我们HTML代码中的回车产生出一个4px的间隙,这个不是bug.而是它的特性,消除这个特性可以使用font-size=0消除.
    2. 第二点是没有水平对齐,导致的原因是在inline-block之后会以文字的基线作为对齐方式,其实没有文字就完全没有问题了,解决这个的方案可以产生一个bfc,让其独立进行计算.或者是设置其vertical-align: top;就是让其垂直排列不以基线对齐.

