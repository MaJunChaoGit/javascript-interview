### 零碎面试知识点

1. **let暂时性死区**

   暂时性死区指一旦进入当前作用域时,所要使用的变量就已经存在了,但是此时无法使用.只有通过定义声明之后才可以使用和获取.

2. **给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值**

   a = a ^ b;   [1000 0001 1001]

   b = a ^ b;   [1001 0001 1000]

   a = a ^ b;   [1001 1000  0001]

3. **数组去重问题**

   var arr = Array.from(new Set([...arr]));

4. **cookie和webStorage的区别，如果cookie被篡改怎么办**

   - cookie的大小受到浏览器的限制,一般只有4K左右

     cookie是对http协议的拓展, cookie的内容保留在请求头中,也就是说每次请求cookie都将伴随在浏览器与服务器间,这样会造成不必要的浪费

     对于服务器端语言来说处理cookie较简单,但是对于前端来说原生的方法还是通过正则表达式进行分割处理

   - sessionStorage的大小为5M.可以存储较多的数据

     sessionStorage与服务器的session相似,是会话级别的数据,一旦关闭浏览器数据将消失

     sessionStorage有非常方便的API

     不同窗口时无法共享数据的

   - localStorage大小也为5M

     他是一种持久化的方案,如果不手动清除不会消失

     不同窗口非跨域的情况可以共享数据

   可以根据业务的需要生成签名,如果签名被篡改则无法通过验证

5. **经常碰见的http状态码**

   - 200	一切正常
   - 101 websocket通信已建立
   - 304 自从上次请求后,请求的网页未修改过.一般配合缓存标头一块使用
   - 400 请求的语法错误
   - 401 前端没有通过鉴权
   - 404 请求路径未找到
   - 405 请求的方法没有匹配
   - 500 服务器遇到了错误

6. **跨域的解决方案**

   - JSONP

     通过script标签进行跨域的请求,通过回调函数接收到服务端的数据,并通过script标签进行运行.

     他的好处是兼容性比较高,但是只能支持GET请求,并且不能够支持iframe之间的通信

   - CORS

     通过服务器设置CORS与请求头中Origin相匹配即可请求

   - PROXY

     通过发送请求给服务端,让服务端代为请求

7. **因为引用计数产生的内存泄漏，在ES6中的解决办法是什么**

   通过WeakMap和WeakSet进行解决,因为是弱类型数据结构,垃圾回收会自动进行回收.

8. **==和===的区别**

   - === 是表示等同符,只有当两边完全相等的时候才会返回true

   - == 是等值符,当两边类型相同时会比较值是否相同,当两边类型不同时,会进行类型的转换

     如果是boolean,string,number类型会优先转换为数字进行比较

     如果是null或undefined是彼此相等的

9. **箭头函数中的this**

   箭头函数在执行中是不存在this上下文的,他将直接捕获父级作用域中this

10. **['1', '2', '3'].map(parseInt)**

    1. parseInt(‘1’, 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1；
    2. parseInt(‘2’, 1) // 基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN；
    3. parseInt(‘3’, 2) // 基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN。

11. **实现一遍双向绑定**

    已有案例

12. **TCP3次握手和4次挥手**

    ​

13. **Promise**

14. **async和await**

15. **Generator**

16. **手写ajax和jsonp**

    已有案例

17. **快速排序**

    已有案例

18. **BFC**

    已有文章

19. **前端缓存**

20. **ajax、axios与fetch有什么区别？**

    - 传统的ajax指的是XMLHttpRequest对象的一系列操作,一般ajax还指的是jQuery对其的封装.在此基础上它还支持jsonp请求,经过多年的使用及改进,使用起来已经非常方便的,但是还是有如下缺点:
      - jQuery整个项目太大,为了使用ajax而对其引入不太符合性能上的要求
      - 基于事件的处理异步方案不友好,回调函数如果存在迭代关系的,会造成ca llback地狱
      - 不符合关注点分离原则,本身是针对MVC的编程,与目前大热的MVVM不太切合
    - Vue中主推的是大家用axios替换ajax方案,axios是一个基于Promise的ajax实现版本 .优点上来说支持Promise的API是大家喜好的主要原因,并且提供了并发请求的接口,且对于拦截请求和响应都有了一系列的支持.
    - fetch号称是ajax的替代品,它不是对XMR封装,它是最原生的js
      - 符合关注点的分离,没有将输入,输出,状态混杂到一个对象中
      - 更好更方便的写法,基于Promise实现,还支持async和await
      - 它默认是不带cookie发送的,并且对于400,500报错的请求,并不会reject,并且不支持abort取消请求,造成了流量的浪费