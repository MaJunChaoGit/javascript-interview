### 零碎面试知识点

1. **let暂时性死区**

   暂时性死区指一旦进入当前作用域时,所要使用的变量就已经存在了,但是此时无法使用.只有通过定义声明之后才可以使用和获取.

2. **给定两个整数a和b，要求在使用任何辅助空间的情况下，交换两个的值**

   a = a ^ b;   [1000 0001 1001]

   b = a ^ b;   [1001 0001 1000]

   a = a ^ b;   [1001 1000  0001]

3. **数组去重问题**

   var arr = Array.from(new Set([...arr]));

4. **cookie和webStorage的区别，如果cookie被篡改怎么办**

   - cookie的大小受到浏览器的限制,一般只有4K左右

     cookie是对http协议的拓展, cookie的内容保留在请求头中,也就是说每次请求cookie都将伴随在浏览器与服务器间,这样会造成不必要的浪费

     对于服务器端语言来说处理cookie较简单,但是对于前端来说原生的方法还是通过正则表达式进行分割处理

   - sessionStorage的大小为5M.可以存储较多的数据

     sessionStorage与服务器的session相似,是会话级别的数据,一旦关闭浏览器数据将消失

     sessionStorage有非常方便的API

     不同窗口时无法共享数据的

   - localStorage大小也为5M

     他是一种持久化的方案,如果不手动清除不会消失

     不同窗口非跨域的情况可以共享数据

   可以根据业务的需要生成签名,如果签名被篡改则无法通过验证

5. **经常碰见的http状态码**

   - 200	一切正常
   - 101 websocket通信已建立
   - 304 自从上次请求后,请求的网页未修改过.一般配合缓存标头一块使用
   - 400 请求的语法错误
   - 401 前端没有通过鉴权
   - 404 请求路径未找到
   - 405 请求的方法没有匹配
   - 500 服务器遇到了错误

6. **跨域的解决方案**

   - JSONP

     通过script标签进行跨域的请求,通过回调函数接收到服务端的数据,并通过script标签进行运行.

     他的好处是兼容性比较高,但是只能支持GET请求,并且不能够支持iframe之间的通信

   - CORS

     通过服务器设置CORS与请求头中Origin相匹配即可请求

   - PROXY

     通过发送请求给服务端,让服务端代为请求

7. **因为引用计数产生的内存泄漏，在ES6中的解决办法是什么**

   通过WeakMap和WeakSet进行解决,因为是弱类型数据结构,垃圾回收会自动进行回收.

8. **类数组有哪些**

   ​

9. **==和===的区别**

   - === 是表示等同符,只有当两边完全相等的时候才会返回true

   - == 是等值符,当两边类型相同时会比较值是否相同,当两边类型不同时,会进行类型的转换

     如果是boolean,string,number类型会优先转换为数字进行比较

     如果是null或undefined是彼此相等的

10. **箭头函数中的this**

    箭头函数在执行中是不存在this上下文的,他将直接捕获父级作用域中this

11. **['1', '2', '3'].map(parseInt)**

    1. parseInt(‘1’, 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1；
    2. parseInt(‘2’, 1) // 基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN；
    3. parseInt(‘3’, 2) // 基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN。

12. **实现一遍双向绑定**

    已有案例

13. **TCP3次握手和4次挥手**

14. **Promise**

15. **async和await**

16. **Generator**

17. **手写ajax和jsonp**

18. **快速排序**

    已有案例

19. **BFC**

    已有文章

20. **前端缓存**